// Copyright 2024 IBN Network (ICTU Blockchain Network)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTransactionStatusHistory = `-- name: AddTransactionStatusHistory :one
INSERT INTO transaction_status_history (transaction_id, status, block_number, details)
VALUES ($1, $2, $3, $4)
RETURNING id, transaction_id, status, block_number, timestamp, details
`

type AddTransactionStatusHistoryParams struct {
	TransactionID pgtype.UUID `json:"transaction_id"`
	Status        string      `json:"status"`
	BlockNumber   pgtype.Int8 `json:"block_number"`
	Details       []byte      `json:"details"`
}

func (q *Queries) AddTransactionStatusHistory(ctx context.Context, db DBTX, arg AddTransactionStatusHistoryParams) (TransactionStatusHistory, error) {
	row := db.QueryRow(ctx, addTransactionStatusHistory,
		arg.TransactionID,
		arg.Status,
		arg.BlockNumber,
		arg.Details,
	)
	var i TransactionStatusHistory
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.Status,
		&i.BlockNumber,
		&i.Timestamp,
		&i.Details,
	)
	return i, err
}

const countTransactions = `-- name: CountTransactions :one
SELECT COUNT(*) FROM transactions
WHERE 
    ($1::text IS NULL OR $1 = '' OR channel_name = $1)
    AND ($2::text IS NULL OR $2 = '' OR chaincode_name = $2)
    AND ($3::text IS NULL OR $3 = '' OR status = $3)
    AND ($4::uuid IS NULL OR user_id = $4)
    AND ($5::timestamp IS NULL OR timestamp >= $5)
    AND ($6::timestamp IS NULL OR timestamp <= $6)
`

type CountTransactionsParams struct {
	Column1 string           `json:"column_1"`
	Column2 string           `json:"column_2"`
	Column3 string           `json:"column_3"`
	Column4 pgtype.UUID      `json:"column_4"`
	Column5 pgtype.Timestamp `json:"column_5"`
	Column6 pgtype.Timestamp `json:"column_6"`
}

func (q *Queries) CountTransactions(ctx context.Context, db DBTX, arg CountTransactionsParams) (int64, error) {
	row := db.QueryRow(ctx, countTransactions,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    tx_id, channel_name, chaincode_name, function_name, args, transient_data,
    user_id, api_key_id, status, block_number, endorsing_orgs
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, tx_id, channel_name, chaincode_name, function_name, args, transient_data, user_id, api_key_id, status, block_number, block_hash, timestamp, error_message, endorsing_orgs, created_at, updated_at
`

type CreateTransactionParams struct {
	TxID          string      `json:"tx_id"`
	ChannelName   string      `json:"channel_name"`
	ChaincodeName string      `json:"chaincode_name"`
	FunctionName  string      `json:"function_name"`
	Args          []byte      `json:"args"`
	TransientData []byte      `json:"transient_data"`
	UserID        pgtype.UUID `json:"user_id"`
	ApiKeyID      pgtype.UUID `json:"api_key_id"`
	Status        string      `json:"status"`
	BlockNumber   pgtype.Int8 `json:"block_number"`
	EndorsingOrgs []string    `json:"endorsing_orgs"`
}

func (q *Queries) CreateTransaction(ctx context.Context, db DBTX, arg CreateTransactionParams) (Transaction, error) {
	row := db.QueryRow(ctx, createTransaction,
		arg.TxID,
		arg.ChannelName,
		arg.ChaincodeName,
		arg.FunctionName,
		arg.Args,
		arg.TransientData,
		arg.UserID,
		arg.ApiKeyID,
		arg.Status,
		arg.BlockNumber,
		arg.EndorsingOrgs,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.ChannelName,
		&i.ChaincodeName,
		&i.FunctionName,
		&i.Args,
		&i.TransientData,
		&i.UserID,
		&i.ApiKeyID,
		&i.Status,
		&i.BlockNumber,
		&i.BlockHash,
		&i.Timestamp,
		&i.ErrorMessage,
		&i.EndorsingOrgs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, tx_id, channel_name, chaincode_name, function_name, args, transient_data, user_id, api_key_id, status, block_number, block_hash, timestamp, error_message, endorsing_orgs, created_at, updated_at FROM transactions WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTransactionByID(ctx context.Context, db DBTX, id pgtype.UUID) (Transaction, error) {
	row := db.QueryRow(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.ChannelName,
		&i.ChaincodeName,
		&i.FunctionName,
		&i.Args,
		&i.TransientData,
		&i.UserID,
		&i.ApiKeyID,
		&i.Status,
		&i.BlockNumber,
		&i.BlockHash,
		&i.Timestamp,
		&i.ErrorMessage,
		&i.EndorsingOrgs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByTxID = `-- name: GetTransactionByTxID :one
SELECT id, tx_id, channel_name, chaincode_name, function_name, args, transient_data, user_id, api_key_id, status, block_number, block_hash, timestamp, error_message, endorsing_orgs, created_at, updated_at FROM transactions WHERE tx_id = $1 LIMIT 1
`

func (q *Queries) GetTransactionByTxID(ctx context.Context, db DBTX, txID string) (Transaction, error) {
	row := db.QueryRow(ctx, getTransactionByTxID, txID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.ChannelName,
		&i.ChaincodeName,
		&i.FunctionName,
		&i.Args,
		&i.TransientData,
		&i.UserID,
		&i.ApiKeyID,
		&i.Status,
		&i.BlockNumber,
		&i.BlockHash,
		&i.Timestamp,
		&i.ErrorMessage,
		&i.EndorsingOrgs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionStatusHistory = `-- name: GetTransactionStatusHistory :many
SELECT id, transaction_id, status, block_number, timestamp, details FROM transaction_status_history
WHERE transaction_id = $1
ORDER BY timestamp DESC
`

func (q *Queries) GetTransactionStatusHistory(ctx context.Context, db DBTX, transactionID pgtype.UUID) ([]TransactionStatusHistory, error) {
	rows, err := db.Query(ctx, getTransactionStatusHistory, transactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TransactionStatusHistory{}
	for rows.Next() {
		var i TransactionStatusHistory
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.Status,
			&i.BlockNumber,
			&i.Timestamp,
			&i.Details,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, tx_id, channel_name, chaincode_name, function_name, args, transient_data, user_id, api_key_id, status, block_number, block_hash, timestamp, error_message, endorsing_orgs, created_at, updated_at FROM transactions
WHERE 
    ($1::text IS NULL OR $1 = '' OR channel_name = $1)
    AND ($2::text IS NULL OR $2 = '' OR chaincode_name = $2)
    AND ($3::text IS NULL OR $3 = '' OR status = $3)
    AND ($4::uuid IS NULL OR user_id = $4)
    AND ($5::timestamp IS NULL OR timestamp >= $5)
    AND ($6::timestamp IS NULL OR timestamp <= $6)
ORDER BY timestamp DESC
LIMIT $7 OFFSET $8
`

type ListTransactionsParams struct {
	Column1 string           `json:"column_1"`
	Column2 string           `json:"column_2"`
	Column3 string           `json:"column_3"`
	Column4 pgtype.UUID      `json:"column_4"`
	Column5 pgtype.Timestamp `json:"column_5"`
	Column6 pgtype.Timestamp `json:"column_6"`
	Limit   int32            `json:"limit"`
	Offset  int32            `json:"offset"`
}

func (q *Queries) ListTransactions(ctx context.Context, db DBTX, arg ListTransactionsParams) ([]Transaction, error) {
	rows, err := db.Query(ctx, listTransactions,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.TxID,
			&i.ChannelName,
			&i.ChaincodeName,
			&i.FunctionName,
			&i.Args,
			&i.TransientData,
			&i.UserID,
			&i.ApiKeyID,
			&i.Status,
			&i.BlockNumber,
			&i.BlockHash,
			&i.Timestamp,
			&i.ErrorMessage,
			&i.EndorsingOrgs,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :one
UPDATE transactions
SET status = $2, block_number = $3, block_hash = $4, error_message = $5, updated_at = NOW()
WHERE id = $1
RETURNING id, tx_id, channel_name, chaincode_name, function_name, args, transient_data, user_id, api_key_id, status, block_number, block_hash, timestamp, error_message, endorsing_orgs, created_at, updated_at
`

type UpdateTransactionStatusParams struct {
	ID           pgtype.UUID `json:"id"`
	Status       string      `json:"status"`
	BlockNumber  pgtype.Int8 `json:"block_number"`
	BlockHash    pgtype.Text `json:"block_hash"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, db DBTX, arg UpdateTransactionStatusParams) (Transaction, error) {
	row := db.QueryRow(ctx, updateTransactionStatus,
		arg.ID,
		arg.Status,
		arg.BlockNumber,
		arg.BlockHash,
		arg.ErrorMessage,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.TxID,
		&i.ChannelName,
		&i.ChaincodeName,
		&i.FunctionName,
		&i.Args,
		&i.TransientData,
		&i.UserID,
		&i.ApiKeyID,
		&i.Status,
		&i.BlockNumber,
		&i.BlockHash,
		&i.Timestamp,
		&i.ErrorMessage,
		&i.EndorsingOrgs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
