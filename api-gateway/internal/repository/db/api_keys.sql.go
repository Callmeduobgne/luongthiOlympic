// Copyright 2024 IBN Network (ICTU Blockchain Network)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: api_keys.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAPIKeysByUser = `-- name: CountAPIKeysByUser :one
SELECT COUNT(*) FROM api_keys WHERE user_id = $1
`

func (q *Queries) CountAPIKeysByUser(ctx context.Context, db DBTX, userID pgtype.UUID) (int64, error) {
	row := db.QueryRow(ctx, countAPIKeysByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAPIKey = `-- name: CreateAPIKey :one
INSERT INTO api_keys (user_id, key_hash, name, permissions, rate_limit, expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, key_hash, name, permissions, rate_limit, is_active, expires_at, last_used_at, created_at, description, allowed_ips
`

type CreateAPIKeyParams struct {
	UserID      pgtype.UUID        `json:"user_id"`
	KeyHash     string             `json:"key_hash"`
	Name        pgtype.Text        `json:"name"`
	Permissions []byte             `json:"permissions"`
	RateLimit   pgtype.Int4        `json:"rate_limit"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateAPIKey(ctx context.Context, db DBTX, arg CreateAPIKeyParams) (ApiKey, error) {
	row := db.QueryRow(ctx, createAPIKey,
		arg.UserID,
		arg.KeyHash,
		arg.Name,
		arg.Permissions,
		arg.RateLimit,
		arg.ExpiresAt,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KeyHash,
		&i.Name,
		&i.Permissions,
		&i.RateLimit,
		&i.IsActive,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.Description,
		&i.AllowedIps,
	)
	return i, err
}

const deleteAPIKey = `-- name: DeleteAPIKey :exec
DELETE FROM api_keys WHERE id = $1
`

func (q *Queries) DeleteAPIKey(ctx context.Context, db DBTX, id pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteAPIKey, id)
	return err
}

const deleteAPIKeysByUser = `-- name: DeleteAPIKeysByUser :exec
DELETE FROM api_keys WHERE user_id = $1
`

func (q *Queries) DeleteAPIKeysByUser(ctx context.Context, db DBTX, userID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteAPIKeysByUser, userID)
	return err
}

const getAPIKey = `-- name: GetAPIKey :one
SELECT id, user_id, key_hash, name, permissions, rate_limit, is_active, expires_at, last_used_at, created_at, description, allowed_ips FROM api_keys WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAPIKey(ctx context.Context, db DBTX, id pgtype.UUID) (ApiKey, error) {
	row := db.QueryRow(ctx, getAPIKey, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KeyHash,
		&i.Name,
		&i.Permissions,
		&i.RateLimit,
		&i.IsActive,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.Description,
		&i.AllowedIps,
	)
	return i, err
}

const getAPIKeyByHash = `-- name: GetAPIKeyByHash :one
SELECT id, user_id, key_hash, name, permissions, rate_limit, is_active, expires_at, last_used_at, created_at, description, allowed_ips FROM api_keys WHERE key_hash = $1 LIMIT 1
`

func (q *Queries) GetAPIKeyByHash(ctx context.Context, db DBTX, keyHash string) (ApiKey, error) {
	row := db.QueryRow(ctx, getAPIKeyByHash, keyHash)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KeyHash,
		&i.Name,
		&i.Permissions,
		&i.RateLimit,
		&i.IsActive,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.Description,
		&i.AllowedIps,
	)
	return i, err
}

const getActiveAPIKeys = `-- name: GetActiveAPIKeys :many
SELECT id, user_id, key_hash, name, permissions, rate_limit, is_active, expires_at, last_used_at, created_at, description, allowed_ips FROM api_keys
WHERE is_active = TRUE
AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
ORDER BY created_at DESC
`

func (q *Queries) GetActiveAPIKeys(ctx context.Context, db DBTX) ([]ApiKey, error) {
	rows, err := db.Query(ctx, getActiveAPIKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKey{}
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.KeyHash,
			&i.Name,
			&i.Permissions,
			&i.RateLimit,
			&i.IsActive,
			&i.ExpiresAt,
			&i.LastUsedAt,
			&i.CreatedAt,
			&i.Description,
			&i.AllowedIps,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAPIKeys = `-- name: ListAPIKeys :many
SELECT id, user_id, key_hash, name, permissions, rate_limit, is_active, expires_at, last_used_at, created_at, description, allowed_ips FROM api_keys
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAPIKeys(ctx context.Context, db DBTX, userID pgtype.UUID) ([]ApiKey, error) {
	rows, err := db.Query(ctx, listAPIKeys, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKey{}
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.KeyHash,
			&i.Name,
			&i.Permissions,
			&i.RateLimit,
			&i.IsActive,
			&i.ExpiresAt,
			&i.LastUsedAt,
			&i.CreatedAt,
			&i.Description,
			&i.AllowedIps,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAPIKey = `-- name: UpdateAPIKey :one
UPDATE api_keys
SET 
    name = COALESCE($1, name),
    permissions = COALESCE($2, permissions),
    rate_limit = COALESCE($3, rate_limit),
    is_active = COALESCE($4, is_active),
    expires_at = COALESCE($5, expires_at)
WHERE id = $6
RETURNING id, user_id, key_hash, name, permissions, rate_limit, is_active, expires_at, last_used_at, created_at, description, allowed_ips
`

type UpdateAPIKeyParams struct {
	Name        pgtype.Text        `json:"name"`
	Permissions []byte             `json:"permissions"`
	RateLimit   pgtype.Int4        `json:"rate_limit"`
	IsActive    pgtype.Bool        `json:"is_active"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	ID          pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateAPIKey(ctx context.Context, db DBTX, arg UpdateAPIKeyParams) (ApiKey, error) {
	row := db.QueryRow(ctx, updateAPIKey,
		arg.Name,
		arg.Permissions,
		arg.RateLimit,
		arg.IsActive,
		arg.ExpiresAt,
		arg.ID,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.KeyHash,
		&i.Name,
		&i.Permissions,
		&i.RateLimit,
		&i.IsActive,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.Description,
		&i.AllowedIps,
	)
	return i, err
}

const updateAPIKeyLastUsed = `-- name: UpdateAPIKeyLastUsed :exec
UPDATE api_keys
SET last_used_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) UpdateAPIKeyLastUsed(ctx context.Context, db DBTX, id pgtype.UUID) error {
	_, err := db.Exec(ctx, updateAPIKeyLastUsed, id)
	return err
}
