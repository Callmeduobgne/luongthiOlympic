// Copyright 2024 IBN Network (ICTU Blockchain Network)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: event_subscriptions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEventSubscriptions = `-- name: CountEventSubscriptions :one
SELECT COUNT(*) FROM event_subscriptions
WHERE 
    ($1::uuid IS NULL OR user_id = $1)
    AND ($2::uuid IS NULL OR api_key_id = $2)
    AND ($3::text IS NULL OR $3 = '' OR channel_name = $3)
    AND ($4::text IS NULL OR $4 = '' OR chaincode_name = $4)
    AND ($5::text IS NULL OR $5 = '' OR type = $5)
    AND ($6::bool IS NULL OR active = $6)
`

type CountEventSubscriptionsParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 pgtype.UUID `json:"column_2"`
	Column3 string      `json:"column_3"`
	Column4 string      `json:"column_4"`
	Column5 string      `json:"column_5"`
	Column6 bool        `json:"column_6"`
}

func (q *Queries) CountEventSubscriptions(ctx context.Context, db DBTX, arg CountEventSubscriptionsParams) (int64, error) {
	row := db.QueryRow(ctx, countEventSubscriptions,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEventSubscription = `-- name: CreateEventSubscription :one
INSERT INTO event_subscriptions (
    user_id, api_key_id, name, type, channel_name, chaincode_name,
    event_name, webhook_url, webhook_secret, filters, active
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, user_id, api_key_id, name, type, channel_name, chaincode_name, event_name, webhook_url, webhook_secret, filters, active, created_at, updated_at
`

type CreateEventSubscriptionParams struct {
	UserID        pgtype.UUID `json:"user_id"`
	ApiKeyID      pgtype.UUID `json:"api_key_id"`
	Name          string      `json:"name"`
	Type          string      `json:"type"`
	ChannelName   string      `json:"channel_name"`
	ChaincodeName pgtype.Text `json:"chaincode_name"`
	EventName     pgtype.Text `json:"event_name"`
	WebhookUrl    pgtype.Text `json:"webhook_url"`
	WebhookSecret pgtype.Text `json:"webhook_secret"`
	Filters       []byte      `json:"filters"`
	Active        bool        `json:"active"`
}

func (q *Queries) CreateEventSubscription(ctx context.Context, db DBTX, arg CreateEventSubscriptionParams) (EventSubscription, error) {
	row := db.QueryRow(ctx, createEventSubscription,
		arg.UserID,
		arg.ApiKeyID,
		arg.Name,
		arg.Type,
		arg.ChannelName,
		arg.ChaincodeName,
		arg.EventName,
		arg.WebhookUrl,
		arg.WebhookSecret,
		arg.Filters,
		arg.Active,
	)
	var i EventSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ApiKeyID,
		&i.Name,
		&i.Type,
		&i.ChannelName,
		&i.ChaincodeName,
		&i.EventName,
		&i.WebhookUrl,
		&i.WebhookSecret,
		&i.Filters,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWebSocketConnection = `-- name: CreateWebSocketConnection :one
INSERT INTO websocket_connections (
    subscription_id, connection_id, user_id, ip_address, user_agent
) VALUES ($1, $2, $3, $4, $5)
RETURNING id, subscription_id, connection_id, user_id, ip_address, user_agent, connected_at, disconnected_at, last_ping_at
`

type CreateWebSocketConnectionParams struct {
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	ConnectionID   string      `json:"connection_id"`
	UserID         pgtype.UUID `json:"user_id"`
	IpAddress      pgtype.Text `json:"ip_address"`
	UserAgent      pgtype.Text `json:"user_agent"`
}

func (q *Queries) CreateWebSocketConnection(ctx context.Context, db DBTX, arg CreateWebSocketConnectionParams) (WebsocketConnection, error) {
	row := db.QueryRow(ctx, createWebSocketConnection,
		arg.SubscriptionID,
		arg.ConnectionID,
		arg.UserID,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i WebsocketConnection
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ConnectionID,
		&i.UserID,
		&i.IpAddress,
		&i.UserAgent,
		&i.ConnectedAt,
		&i.DisconnectedAt,
		&i.LastPingAt,
	)
	return i, err
}

const createWebhookDelivery = `-- name: CreateWebhookDelivery :one
INSERT INTO webhook_deliveries (
    subscription_id, event_id, webhook_url, payload, status, attempts
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, subscription_id, event_id, webhook_url, payload, status, status_code, response_body, error_message, attempts, delivered_at, created_at
`

type CreateWebhookDeliveryParams struct {
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	EventID        string      `json:"event_id"`
	WebhookUrl     string      `json:"webhook_url"`
	Payload        []byte      `json:"payload"`
	Status         string      `json:"status"`
	Attempts       int32       `json:"attempts"`
}

func (q *Queries) CreateWebhookDelivery(ctx context.Context, db DBTX, arg CreateWebhookDeliveryParams) (WebhookDelivery, error) {
	row := db.QueryRow(ctx, createWebhookDelivery,
		arg.SubscriptionID,
		arg.EventID,
		arg.WebhookUrl,
		arg.Payload,
		arg.Status,
		arg.Attempts,
	)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.EventID,
		&i.WebhookUrl,
		&i.Payload,
		&i.Status,
		&i.StatusCode,
		&i.ResponseBody,
		&i.ErrorMessage,
		&i.Attempts,
		&i.DeliveredAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEventSubscription = `-- name: DeleteEventSubscription :exec
DELETE FROM event_subscriptions WHERE id = $1
`

func (q *Queries) DeleteEventSubscription(ctx context.Context, db DBTX, id pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteEventSubscription, id)
	return err
}

const deleteWebSocketConnection = `-- name: DeleteWebSocketConnection :exec
DELETE FROM websocket_connections WHERE id = $1
`

func (q *Queries) DeleteWebSocketConnection(ctx context.Context, db DBTX, id pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteWebSocketConnection, id)
	return err
}

const getActiveSubscriptionsByChannelAndChaincode = `-- name: GetActiveSubscriptionsByChannelAndChaincode :many
SELECT id, user_id, api_key_id, name, type, channel_name, chaincode_name, event_name, webhook_url, webhook_secret, filters, active, created_at, updated_at FROM event_subscriptions
WHERE active = true
    AND channel_name = $1
    AND ($2::text IS NULL OR $2 = '' OR chaincode_name = $2)
    AND ($3::text IS NULL OR $3 = '' OR event_name = $3 OR event_name IS NULL)
`

type GetActiveSubscriptionsByChannelAndChaincodeParams struct {
	ChannelName string `json:"channel_name"`
	Column2     string `json:"column_2"`
	Column3     string `json:"column_3"`
}

func (q *Queries) GetActiveSubscriptionsByChannelAndChaincode(ctx context.Context, db DBTX, arg GetActiveSubscriptionsByChannelAndChaincodeParams) ([]EventSubscription, error) {
	rows, err := db.Query(ctx, getActiveSubscriptionsByChannelAndChaincode, arg.ChannelName, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EventSubscription{}
	for rows.Next() {
		var i EventSubscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ApiKeyID,
			&i.Name,
			&i.Type,
			&i.ChannelName,
			&i.ChaincodeName,
			&i.EventName,
			&i.WebhookUrl,
			&i.WebhookSecret,
			&i.Filters,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventSubscriptionByID = `-- name: GetEventSubscriptionByID :one
SELECT id, user_id, api_key_id, name, type, channel_name, chaincode_name, event_name, webhook_url, webhook_secret, filters, active, created_at, updated_at FROM event_subscriptions WHERE id = $1 LIMIT 1
`

func (q *Queries) GetEventSubscriptionByID(ctx context.Context, db DBTX, id pgtype.UUID) (EventSubscription, error) {
	row := db.QueryRow(ctx, getEventSubscriptionByID, id)
	var i EventSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ApiKeyID,
		&i.Name,
		&i.Type,
		&i.ChannelName,
		&i.ChaincodeName,
		&i.EventName,
		&i.WebhookUrl,
		&i.WebhookSecret,
		&i.Filters,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWebSocketConnectionByConnectionID = `-- name: GetWebSocketConnectionByConnectionID :one
SELECT id, subscription_id, connection_id, user_id, ip_address, user_agent, connected_at, disconnected_at, last_ping_at FROM websocket_connections WHERE connection_id = $1 LIMIT 1
`

func (q *Queries) GetWebSocketConnectionByConnectionID(ctx context.Context, db DBTX, connectionID string) (WebsocketConnection, error) {
	row := db.QueryRow(ctx, getWebSocketConnectionByConnectionID, connectionID)
	var i WebsocketConnection
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ConnectionID,
		&i.UserID,
		&i.IpAddress,
		&i.UserAgent,
		&i.ConnectedAt,
		&i.DisconnectedAt,
		&i.LastPingAt,
	)
	return i, err
}

const getWebSocketConnectionByID = `-- name: GetWebSocketConnectionByID :one
SELECT id, subscription_id, connection_id, user_id, ip_address, user_agent, connected_at, disconnected_at, last_ping_at FROM websocket_connections WHERE id = $1 LIMIT 1
`

func (q *Queries) GetWebSocketConnectionByID(ctx context.Context, db DBTX, id pgtype.UUID) (WebsocketConnection, error) {
	row := db.QueryRow(ctx, getWebSocketConnectionByID, id)
	var i WebsocketConnection
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ConnectionID,
		&i.UserID,
		&i.IpAddress,
		&i.UserAgent,
		&i.ConnectedAt,
		&i.DisconnectedAt,
		&i.LastPingAt,
	)
	return i, err
}

const listEventSubscriptions = `-- name: ListEventSubscriptions :many
SELECT id, user_id, api_key_id, name, type, channel_name, chaincode_name, event_name, webhook_url, webhook_secret, filters, active, created_at, updated_at FROM event_subscriptions
WHERE 
    ($1::uuid IS NULL OR user_id = $1)
    AND ($2::uuid IS NULL OR api_key_id = $2)
    AND ($3::text IS NULL OR $3 = '' OR channel_name = $3)
    AND ($4::text IS NULL OR $4 = '' OR chaincode_name = $4)
    AND ($5::text IS NULL OR $5 = '' OR type = $5)
    AND ($6::bool IS NULL OR active = $6)
ORDER BY created_at DESC
LIMIT $7 OFFSET $8
`

type ListEventSubscriptionsParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 pgtype.UUID `json:"column_2"`
	Column3 string      `json:"column_3"`
	Column4 string      `json:"column_4"`
	Column5 string      `json:"column_5"`
	Column6 bool        `json:"column_6"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) ListEventSubscriptions(ctx context.Context, db DBTX, arg ListEventSubscriptionsParams) ([]EventSubscription, error) {
	rows, err := db.Query(ctx, listEventSubscriptions,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EventSubscription{}
	for rows.Next() {
		var i EventSubscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ApiKeyID,
			&i.Name,
			&i.Type,
			&i.ChannelName,
			&i.ChaincodeName,
			&i.EventName,
			&i.WebhookUrl,
			&i.WebhookSecret,
			&i.Filters,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebSocketConnections = `-- name: ListWebSocketConnections :many
SELECT id, subscription_id, connection_id, user_id, ip_address, user_agent, connected_at, disconnected_at, last_ping_at FROM websocket_connections
WHERE subscription_id = $1
    AND disconnected_at IS NULL
ORDER BY connected_at DESC
`

func (q *Queries) ListWebSocketConnections(ctx context.Context, db DBTX, subscriptionID pgtype.UUID) ([]WebsocketConnection, error) {
	rows, err := db.Query(ctx, listWebSocketConnections, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebsocketConnection{}
	for rows.Next() {
		var i WebsocketConnection
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.ConnectionID,
			&i.UserID,
			&i.IpAddress,
			&i.UserAgent,
			&i.ConnectedAt,
			&i.DisconnectedAt,
			&i.LastPingAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookDeliveries = `-- name: ListWebhookDeliveries :many
SELECT id, subscription_id, event_id, webhook_url, payload, status, status_code, response_body, error_message, attempts, delivered_at, created_at FROM webhook_deliveries
WHERE subscription_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListWebhookDeliveriesParams struct {
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

func (q *Queries) ListWebhookDeliveries(ctx context.Context, db DBTX, arg ListWebhookDeliveriesParams) ([]WebhookDelivery, error) {
	rows, err := db.Query(ctx, listWebhookDeliveries, arg.SubscriptionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.EventID,
			&i.WebhookUrl,
			&i.Payload,
			&i.Status,
			&i.StatusCode,
			&i.ResponseBody,
			&i.ErrorMessage,
			&i.Attempts,
			&i.DeliveredAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventSubscription = `-- name: UpdateEventSubscription :one
UPDATE event_subscriptions
SET 
    name = COALESCE($2, name),
    active = COALESCE($3, active),
    webhook_url = COALESCE($4, webhook_url),
    webhook_secret = COALESCE($5, webhook_secret),
    filters = COALESCE($6, filters),
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, api_key_id, name, type, channel_name, chaincode_name, event_name, webhook_url, webhook_secret, filters, active, created_at, updated_at
`

type UpdateEventSubscriptionParams struct {
	ID            pgtype.UUID `json:"id"`
	Name          string      `json:"name"`
	Active        bool        `json:"active"`
	WebhookUrl    pgtype.Text `json:"webhook_url"`
	WebhookSecret pgtype.Text `json:"webhook_secret"`
	Filters       []byte      `json:"filters"`
}

func (q *Queries) UpdateEventSubscription(ctx context.Context, db DBTX, arg UpdateEventSubscriptionParams) (EventSubscription, error) {
	row := db.QueryRow(ctx, updateEventSubscription,
		arg.ID,
		arg.Name,
		arg.Active,
		arg.WebhookUrl,
		arg.WebhookSecret,
		arg.Filters,
	)
	var i EventSubscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ApiKeyID,
		&i.Name,
		&i.Type,
		&i.ChannelName,
		&i.ChaincodeName,
		&i.EventName,
		&i.WebhookUrl,
		&i.WebhookSecret,
		&i.Filters,
		&i.Active,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWebSocketConnection = `-- name: UpdateWebSocketConnection :one
UPDATE websocket_connections
SET 
    disconnected_at = $2,
    last_ping_at = $3
WHERE id = $1
RETURNING id, subscription_id, connection_id, user_id, ip_address, user_agent, connected_at, disconnected_at, last_ping_at
`

type UpdateWebSocketConnectionParams struct {
	ID             pgtype.UUID      `json:"id"`
	DisconnectedAt pgtype.Timestamp `json:"disconnected_at"`
	LastPingAt     pgtype.Timestamp `json:"last_ping_at"`
}

func (q *Queries) UpdateWebSocketConnection(ctx context.Context, db DBTX, arg UpdateWebSocketConnectionParams) (WebsocketConnection, error) {
	row := db.QueryRow(ctx, updateWebSocketConnection, arg.ID, arg.DisconnectedAt, arg.LastPingAt)
	var i WebsocketConnection
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.ConnectionID,
		&i.UserID,
		&i.IpAddress,
		&i.UserAgent,
		&i.ConnectedAt,
		&i.DisconnectedAt,
		&i.LastPingAt,
	)
	return i, err
}

const updateWebhookDelivery = `-- name: UpdateWebhookDelivery :one
UPDATE webhook_deliveries
SET 
    status = $2,
    status_code = $3,
    response_body = $4,
    error_message = $5,
    attempts = $6,
    delivered_at = $7
WHERE id = $1
RETURNING id, subscription_id, event_id, webhook_url, payload, status, status_code, response_body, error_message, attempts, delivered_at, created_at
`

type UpdateWebhookDeliveryParams struct {
	ID           pgtype.UUID      `json:"id"`
	Status       string           `json:"status"`
	StatusCode   pgtype.Int4      `json:"status_code"`
	ResponseBody pgtype.Text      `json:"response_body"`
	ErrorMessage pgtype.Text      `json:"error_message"`
	Attempts     int32            `json:"attempts"`
	DeliveredAt  pgtype.Timestamp `json:"delivered_at"`
}

func (q *Queries) UpdateWebhookDelivery(ctx context.Context, db DBTX, arg UpdateWebhookDeliveryParams) (WebhookDelivery, error) {
	row := db.QueryRow(ctx, updateWebhookDelivery,
		arg.ID,
		arg.Status,
		arg.StatusCode,
		arg.ResponseBody,
		arg.ErrorMessage,
		arg.Attempts,
		arg.DeliveredAt,
	)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.EventID,
		&i.WebhookUrl,
		&i.Payload,
		&i.Status,
		&i.StatusCode,
		&i.ResponseBody,
		&i.ErrorMessage,
		&i.Attempts,
		&i.DeliveredAt,
		&i.CreatedAt,
	)
	return i, err
}
